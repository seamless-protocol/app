# Phase II Leverage Tokens ‚Äì Handoff (2025-09-03)

## üéØ Current Status: Live Read Integration Planned (No Mock Flag)

The token detail page currently renders from mock data (`src/features/leverage-tokens/data/mockData.ts`). We have real contracts, addresses, and hook infrastructure available (wagmi + TanStack Query). We will replace mock consumption with live reads and keep the UI unchanged. No mock feature flag is used ‚Äî the page will read live data by default.

---

## ‚úÖ What's Been Implemented

- New planning doc added: `docs/leverage-tokens-data-plan.md` (scope, data model, hook plan, phased approach).
- New branch created for today‚Äôs work: `handoff/2025-09-03-live-leverage-data`.
- No app code changes yet ‚Äî this document details the implementation plan and task breakdown.

---

## ‚ùå What's NOT Complete (Critical Gaps)

- Live read hooks for leverage token slices are not yet implemented (`Core`, `Supply`, `UserPosition`, etc.).
- Token detail route still imports mock data (`leverageTokenPageData`).
- Off-chain price and history provider not selected; adapter interface not implemented.
- Risk and rebalancing parameters may require ABI extensions.
- Prior gap remains: SwapContext for DEX routing (Router mint) still placeholder in write flow.

---

## üîß Files To Change (Planned)

New hooks (slice-level):
- `src/features/leverage-tokens/hooks/useLeverageTokenCore.ts`
- `src/features/leverage-tokens/hooks/useLeverageTokenSupply.ts`
- `src/features/leverage-tokens/hooks/useUserPosition.ts`
- (Later) `useLeverageTokenMarket.ts`, `usePriceHistory.ts`, `useLeverageTokenApy.ts`, `useLeverageTokenRisk.ts`, `useRebalancingStatus.ts`

Aggregator hook:
- `src/features/leverage-tokens/hooks/useLeverageTokenPageData.ts`

Route wiring:
- `src/routes/tokens.$id.tsx` (replace mock consumption, map live slices to UI props)
- `src/routes/tokens.index.tsx` (prefetch core/supply on token click)

Types/utilities (if needed):
- `src/features/leverage-tokens/types/index.ts` (ensure domain models cover new fields)
- `src/features/leverage-tokens/utils/queryKeys.ts` (reuse existing `ltKeys`)
- `src/features/leverage-tokens/utils/constants.ts` (`STALE_TIME` already matches needs)

---

## üåÖ Getting Started Tomorrow Morning

### Before Tech Lead Arrives (45‚Äì60 min)
1. Repo readiness (10 min)
   - `git checkout handoff/2025-09-03-live-leverage-data && bun install && bun run build`
   - Skim `docs/leverage-tokens-data-plan.md` and this handoff document.
2. Contracts/ABIs check (10 min)
   - Confirm `addresses.ts` Base addresses are correct for Manager/Router.
   - Validate minimal ABIs cover: ERC20 (name/symbol/decimals/totalSupply/balanceOf), Manager (collateral/debt, previewMint). Identify any gaps for risk/caps/rebalance.
3. Hook scaffolding pass (30‚Äì40 min)
   - Implement `useLeverageTokenCore` and `useLeverageTokenSupply` with `readContracts` multicall and `ltKeys`/`STALE_TIME`.
   - Implement `useUserPosition` (wallet-gated) for balance + valuation placeholder (spot price TBD).

### First Tech Lead Discussion
- Confirm initial slices and route wiring approach (no feature flag, live by default).
- Decide interim spot price strategy (temporary constant vs. immediate adapter wiring).
- Confirm ABI extensions required for caps/risk/rebalance.

---

## üö® Immediate Next Steps for Handoff Engineer (Nitty-Gritty)

1) Implement `useLeverageTokenCore(token: Address)`
- Source: ERC20 + Manager reads via `readContracts`.
- Output (domain model): `{ name, symbol, decimals, address, chainId, collateralAsset, debtAsset }` and placeholder `leverageRatio` if not on-chain yet.
- Cache: `ltKeys.metadata(token)`, `staleTime: STALE_TIME.metadata`.
- Errors: Throw on any failed required call; partials not allowed for core.

2) Implement `useLeverageTokenSupply(token)`
- Source: ERC20 `totalSupply`; supply cap if exposed (Manager/Factory); else `undefined` and UI handles gracefully.
- Derived: utilization if cap exists; `isNearCapacity` threshold at 90%.
- Cache: `ltKeys.supply(token)`, `staleTime: STALE_TIME.supply`.

3) Implement `useUserPosition(token, owner)`
- Enable only when `owner` is defined (wagmi `useAccount`).
- Source: ERC20 `balanceOf(owner)`. For `value`, temporarily compute as `balance * spotPrice` where spotPrice is a placeholder (e.g., 1) until `useLeverageTokenMarket` lands.
- Cache: `ltKeys.user(token, owner)`, `staleTime: STALE_TIME.balance`.

4) Add `useLeverageTokenPageData(token)` (aggregator)
- Compose the above three hooks; return structured `{ core, supply, user }` with loading/error states per slice.
- Do not merge data into a single object to preserve granular states.

5) Wire `src/routes/tokens.$id.tsx`
- Remove `leverageTokenPageData` mock import.
- Call `useLeverageTokenPageData(tokenAddressFromRoute)`.
- Map domain ‚Üí view props:
  - Header: `core.name`, `core.collateralAsset/debtAsset` for `AssetDisplay`.
  - Stat cards: TVL/metrics still mock for now; replace only what we have live (e.g., supply when available).
  - Holdings card: use `user.balance` (format) and existing APY badge still mock until market/apy hooks land.
  - Chart: keep mock history until `usePriceHistory` exists.
- UI must render progressively: show skeletons or placeholders where slices are loading.

6) Prefetch in `src/routes/tokens.index.tsx`
- On token click (before navigate), prefetch `ltKeys.metadata(token)` and `ltKeys.supply(token)`.
- Navigate after prefetch call fires (no hard wait), improving perceived load.

7) Targeted invalidation (align with writes)
- `useMintViaRouter` already invalidates `ltKeys.user(token, user)` and `ltKeys.supply(token)`; ensure keys match slice keys above.

8) Error handling and formatting
- Use existing formatters for BigInt conversion in view mapping.
- Handle individual slice errors with non-blocking toasts/logs and present fallback UI text.

---

## üìã Architecture Decisions Made

- No mock flag: token page uses live reads by default.
- Granular hooks per data category with `ltKeys` and `STALE_TIME`.
- BigInt for on-chain values; format at the route/UI boundary.
- Aggregator hook composes slices but preserves independent loading/error.
- Off-chain price/history/APY will be integrated via adapters in subsequent phases.

---

## üîç Key Discoveries

- Existing infra found: `ltKeys`, `STALE_TIME`, `useMintViaRouter`, ABIs (Manager/Router/Token), Base addresses.
- Route `tokens.$id.tsx` cleanly maps to components; easy to feed slice data progressively.
- Prior gap (DEX routing SwapContext) remains out-of-scope for read-side work but should be tracked.

---

## üéØ Success Criteria for Completion

Minimum viable live-read integration for the token page:
- [ ] `useLeverageTokenCore`, `useLeverageTokenSupply`, `useUserPosition` implemented and tested locally.
- [ ] `tokens.$id.tsx` switched from mock to aggregator; page renders with live token name/symbol/decimals and assets.
- [ ] Holdings section shows live balance (when connected) and degrades gracefully when disconnected.
- [ ] Prefetch added to tokens index for core/supply keys.
- [ ] No console errors; section-level loaders/errors behave as expected.

Stretch (if time permits):
- [ ] Draft `PriceProvider` adapter interface and stub `useLeverageTokenMarket`/`usePriceHistory`.
- [ ] Identify ABI endpoints (or events) for caps/risk/rebalance and plan extensions.

---

## üìé References

- Planning doc: `docs/leverage-tokens-data-plan.md`
- Contracts/addresses: `src/lib/contracts/addresses.ts`
- ABIs: `src/lib/contracts/abis/*`
- Query infra: `src/features/leverage-tokens/utils/{queryKeys.ts,constants.ts}`
- Write flow: `src/features/leverage-tokens/hooks/useMintViaRouter.ts`

